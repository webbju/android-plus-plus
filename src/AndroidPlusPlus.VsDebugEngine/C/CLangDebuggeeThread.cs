////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;
using Microsoft.VisualStudio.Debugger.Interop;
using System;
using System.Collections.Generic;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  public class CLangDebuggeeThread : DebuggeeThread
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected readonly CLangDebugger m_debugger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public CLangDebuggeeThread (CLangDebugger debugger, CLangDebuggeeProgram program, uint id)
      : base (program.DebugProgram, id, $"[Native-{id}]")
    {
      m_debugger = debugger;

      NativeProgram = program;

      RequiresRefresh = true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public CLangDebuggeeProgram NativeProgram { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public bool RequiresRefresh { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Refresh (ref MiResultValue threadData)
    {
      LoggingUtils.PrintFunction ();

      if (threadData.HasField ("name"))
      {
        m_threadDisplayName = threadData ["name"] [0].GetString (); // user-specified name
      }
      else if (threadData.HasField ("target-id"))
      {
        m_threadDisplayName = threadData ["target-id"] [0].GetString (); // usually the raw name, i.e. 'Thread 18771'
      }

      if (threadData.HasField ("frame"))
      {
        var frameTuple = threadData ["frame"] [0] as MiResultValueTuple;

        uint stackLevel = frameTuple ["level"] [0].GetUnsignedInt ();

        string stackFrameId = m_threadName + "#" + stackLevel;

        var stackFrame = new CLangDebuggeeStackFrame (m_debugger, this, frameTuple, stackFrameId);

        m_threadStackFrames.Add (stackFrame);
      }

      RequiresRefresh = false;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public override List<DebuggeeStackFrame> StackTrace (uint depth)
    {
      // 
      // Each thread maintains an internal cache of the last reported stack-trace. This is only cleared when threads are resumed via 'SetRunning(true)'.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        if (m_threadStackFrames.Count < depth)
        {
          LoggingUtils.RequireOk(GetThreadId(out uint threadId));

          m_debugger.RunInterruptOperation (async (CLangDebugger debugger) =>
          {
            // 
            // Determine the maximum available stack depth.
            // 

            if (depth == uint.MaxValue)
            {
              string command = string.Format ("-stack-info-depth --thread {0}", threadId);

              var resultRecord = debugger.GdbClient.SendSyncCommand (command);

              MiResultRecord.RequireOk (resultRecord, command);

              depth = resultRecord ["depth"] [0].GetUnsignedInt ();
            }

            // 
            // Acquire stack frame information for any levels which we're missing.
            // 

            if (m_threadStackFrames.Count < depth)
            {
              string command = string.Format ("-stack-list-frames --thread {0} {1} {2}", threadId, m_threadStackFrames.Count, depth - 1);

              var resultRecord = debugger.GdbClient.SendSyncCommand (command);

              MiResultRecord.RequireOk (resultRecord, command);

              if (resultRecord.HasField ("stack"))
              {
                MiResultValueList stackRecord = resultRecord ["stack"] [0] as MiResultValueList;

                for (int i = 0; i < stackRecord.Values.Count; ++i)
                {
                  MiResultValueTuple frameTuple = stackRecord [i] as MiResultValueTuple;

                  uint stackLevel = frameTuple ["level"] [0].GetUnsignedInt ();

                  string stackFrameId = m_threadName + "#" + stackLevel;

                  CLangDebuggeeStackFrame stackFrame = new CLangDebuggeeStackFrame (debugger, this, frameTuple, stackFrameId);

                  m_threadStackFrames.Add (stackFrame);
                }
              }
            }
          });
        }

        return m_threadStackFrames;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        throw;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public override int SetNextStatement (IDebugStackFrame2 stackFrame, IDebugCodeContext2 codeContext)
    {
      // 
      // Sets the next statement to the given stack frame and code context.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        var contextInfo = new CONTEXT_INFO [1];

        LoggingUtils.RequireOk (codeContext.GetInfo (enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE, contextInfo));

        m_debugger.RunInterruptOperation (async (CLangDebugger debugger) =>
        {
          // 
          // Create a temporary breakpoint to stop -exec-jump continuing when we'd rather it didn't.
          // 

          string location = "*" + contextInfo[0].bstrAddressAbsolute;

          string command = string.Format ("-break-insert -t \"{0}\"", location);

          MiResultRecord resultRecord = debugger.GdbClient.SendSyncCommand (command);

          MiResultRecord.RequireOk (resultRecord, command);

          // 
          // Jump to the specified address location.
          // 

          command = string.Format ("-exec-jump --thread {0} \"{1}\"", m_threadId, location);

          resultRecord = debugger.GdbClient.SendSyncCommand (command);

          MiResultRecord.RequireOk (resultRecord, command);
        });

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

}
