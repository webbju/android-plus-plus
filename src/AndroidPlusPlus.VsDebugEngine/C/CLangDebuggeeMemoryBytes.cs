////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;
using Microsoft.VisualStudio.Debugger.Interop;
using System;
using System.Globalization;
using System.Text;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  public class CLangDebuggeeMemoryBytes : IDebugMemoryBytes2
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private readonly CLangDebugger m_debugger;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public CLangDebuggeeMemoryBytes (CLangDebugger debugger)
    {
      m_debugger = debugger;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetSize (out ulong pqwSize)
    {
      // 
      // Gets the size, in bytes, of the memory represented by this interface.
      // 

      LoggingUtils.PrintFunction ();

      pqwSize = 0xffffffffL;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int ReadAt (IDebugMemoryContext2 pStartContext, uint dwCount, byte [] rgbMemory, out uint pdwRead, ref uint pdwUnreadable)
    {
      // 
      // Reads a sequence of bytes, starting at a given location.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        CONTEXT_INFO [] contextInfoArray = new CONTEXT_INFO [1];

        LoggingUtils.RequireOk (pStartContext.GetInfo (enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE, contextInfoArray));

        string command = string.Format ("-data-read-memory-bytes {0} {1}", contextInfoArray [0].bstrAddressAbsolute, dwCount);

        MiResultRecord resultRecord = m_debugger.GdbClient.SendSyncCommand (command);

        MiResultRecord.RequireOk (resultRecord, command);

        MiResultValueList memoryStreamList = (MiResultValueList) resultRecord ["memory"] [0];

        for (int s = 0; s < memoryStreamList.Values.Count; ++s)
        {
          if (!memoryStreamList [s].HasField ("contents"))
          {
            throw new InvalidOperationException ("-data-read-memory-bytes result missing 'contents' field");
          }

          string hexValue = memoryStreamList [s] ["contents"] [0].GetString ();

          if ((hexValue.Length / 2) != dwCount)
          {
            throw new InvalidOperationException ();
          }

          for (int i = 0; i < dwCount; ++i)
          {
            rgbMemory [i] = byte.Parse (hexValue.Substring (i * 2, 2), NumberStyles.HexNumber);
          }
        }

        pdwRead = dwCount;

        pdwUnreadable = 0;

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        pdwRead = 0;

        pdwUnreadable = dwCount;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int WriteAt (IDebugMemoryContext2 pStartContext, uint dwCount, byte [] rgbMemory)
    {
      // 
      // Writes the specified number of bytes of memory, starting at the specified address.
      // 

      LoggingUtils.PrintFunction ();

      try
      {
        CONTEXT_INFO [] contextInfoArray = new CONTEXT_INFO [1];

        LoggingUtils.RequireOk (pStartContext.GetInfo (enum_CONTEXT_INFO_FIELDS.CIF_ADDRESSABSOLUTE, contextInfoArray));

        StringBuilder stringBuilder = new StringBuilder ((int)dwCount * 2);

        for (uint i = 0; i < dwCount; ++i)
        {
          stringBuilder.Append (rgbMemory [i].ToString ("x"));
        }

        string command = string.Format ("-data-write-memory-bytes {0} {1} {2}", contextInfoArray [0].bstrAddressAbsolute, stringBuilder.ToString (), dwCount);

        MiResultRecord resultRecord = m_debugger.GdbClient.SendSyncCommand (command);

        MiResultRecord.RequireOk (resultRecord, command);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

}
