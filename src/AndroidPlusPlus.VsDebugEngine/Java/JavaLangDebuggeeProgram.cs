////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.VisualStudio.Debugger.Interop;
using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public class JavaLangDebuggeeProgram : IDebugProgram3
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected readonly JavaLangDebugger m_debugger;

    protected List<DebuggeeModule> m_debugModules;

    protected Dictionary<uint, DebuggeeThread> m_debugThreads;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public JavaLangDebuggeeProgram (JavaLangDebugger debugger, DebuggeeProgram debugProgram)
    {
      m_debugger = debugger;

      DebugProgram = debugProgram;

      IsRunning = false;

      m_debugModules = new List<DebuggeeModule> ();

      m_debugThreads = new Dictionary<uint, DebuggeeThread> ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebuggeeProgram DebugProgram { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public bool IsRunning { get; protected set; }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void SetRunning (bool isRunning)
    {
      LoggingUtils.PrintFunction ();

      IsRunning = isRunning;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugProgram2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Attach (IDebugEventCallback2 pCallback)
    {
      //
      // Attaches to this program.
      //

      LoggingUtils.PrintFunction ();

      Exception rethrowable = null;

      try
      {
        m_debugger.Engine.Broadcast (new JavaLangDebuggerEvent.AttachClient (), DebugProgram, null);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        rethrowable = e;

        return Constants.E_FAIL;
      }
      finally
      {
        if (rethrowable != null)
        {
          throw rethrowable;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int CanDetach ()
    {
      LoggingUtils.PrintFunction ();

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int CauseBreak ()
    {
      LoggingUtils.PrintFunction ();

      Exception rethrowable = null;

      try
      {
        m_debugger.Engine.Broadcast (new JavaLangDebuggerEvent.StopClient (), DebugProgram, null);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        rethrowable = e;

        return Constants.E_FAIL;
      }
      finally
      {
        if (rethrowable != null)
        {
          throw rethrowable;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Continue (IDebugThread2 pThread)
    {
      LoggingUtils.PrintFunction ();

      Exception rethrowable = null;

      try
      {
        if (!IsRunning)
        {
          m_debugger.Engine.Broadcast (new JavaLangDebuggerEvent.ContinueClient (), DebugProgram, null);
        }

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        rethrowable = e;

        return Constants.E_FAIL;
      }
      finally
      {
        if (rethrowable != null)
        {
          throw rethrowable;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Detach ()
    {
      LoggingUtils.PrintFunction ();

      Exception rethrowable = null;

      try
      {
        m_debugger.Engine.Broadcast (new JavaLangDebuggerEvent.DetachClient (), DebugProgram, null);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        rethrowable = e;

        return Constants.E_FAIL;
      }
      finally
      {
        if (rethrowable != null)
        {
          throw rethrowable;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumCodeContexts (IDebugDocumentPosition2 pDocPos, out IEnumDebugCodeContexts2 ppEnum)
    {
      //
      // Enumerates the code contexts for a given position in a source file.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        string fileName;

        TEXT_POSITION [] startPos = new TEXT_POSITION [1];

        TEXT_POSITION [] endPos = new TEXT_POSITION [1];

        LoggingUtils.RequireOk (pDocPos.GetFileName (out fileName));

        LoggingUtils.RequireOk (pDocPos.GetRange (startPos, endPos));

        string location = string.Format ("\"{0}:{1}\"", fileName, startPos [0].dwLine + 1);

        DebuggeeCodeContext codeContext = m_debugger.GetCodeContextForLocation (location) ?? throw new InvalidOperationException ("Failed evaluating code-context for location.");

        DebuggeeCodeContext [] codeContexts = new DebuggeeCodeContext [] { codeContext };

        ppEnum = new DebuggeeCodeContext.Enumerator (codeContexts);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        ppEnum = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumCodePaths (string pszHint, IDebugCodeContext2 pStart, IDebugStackFrame2 pFrame, int fSource, out IEnumCodePaths2 ppEnum, out IDebugCodeContext2 ppSafety)
    {
      //
      // Enumerates the code paths of this program.
      //

      LoggingUtils.PrintFunction ();

#if false
      try
      {
        //
        // Get the entire call-stack for the current thread, and enumerate.
        //

        CLangDebuggeeStackFrame stackFrame = pFrame as CLangDebuggeeStackFrame;

        IDebugThread2 thread;

        LoggingUtils.RequireOk (stackFrame.GetThread (out thread));

        CLangDebuggeeThread stackFrameThread = thread as CLangDebuggeeThread;

        List<DebuggeeStackFrame> threadCallStack = stackFrameThread.StackTrace (uint.MaxValue);

        List<CODE_PATH> threadCodePaths = new List<CODE_PATH> ();

        for (int i = 0; i < threadCallStack.Count; ++i)
        {
          string frameName;

          IDebugCodeContext2 codeContext;

          DebuggeeStackFrame frame = threadCallStack [i] as DebuggeeStackFrame;

          LoggingUtils.RequireOk (frame.GetName (out frameName));

          LoggingUtils.RequireOk (frame.GetCodeContext (out codeContext));

          if (codeContext != null)
          {
            CODE_PATH codePath = new CODE_PATH ();

            codePath.bstrName = frameName;

            codePath.pCode = codeContext;

            threadCodePaths.Add (codePath);
          }
        }

        ppEnum = new DebuggeeProgram.EnumeratorCodePaths (threadCodePaths);

        ppSafety = null;

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);
#endif
      {
        ppEnum = null;

        ppSafety = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumModules (out IEnumDebugModules2 ppEnum)
    {
      //
      // Enumerates the modules that this program has loaded and is executing.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        List<IDebugModule2> modules = new List<IDebugModule2> ();

        foreach (DebuggeeModule module in m_debugModules)
        {
          modules.Add (module as IDebugModule2);
        }

        ppEnum = new DebuggeeModule.Enumerator (modules);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        ppEnum = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumThreads (out IEnumDebugThreads2 ppEnum)
    {
      //
      // Enumerates the threads that are running in this program.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        List<IDebugThread2> threads = new List<IDebugThread2> ();

        threads.AddRange (m_debugThreads.Values);

        ppEnum = new DebuggeeThread.Enumerator (threads);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        ppEnum = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetDebugProperty (out IDebugProperty2 ppProperty)
    {
      //
      // Gets program properties.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        ppProperty = null;

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Execute ()
    {
      //
      // Continues running this program from a stopped state. Any previous execution state is cleared.
      //

      LoggingUtils.PrintFunction ();

      try
      {
#if false
        LoggingUtils.RequireOk (Continue (GetThread (CurrentThreadId)));
#endif

        throw new NotImplementedException ();

        //return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetDisassemblyStream (enum_DISASSEMBLY_STREAM_SCOPE dwScope, IDebugCodeContext2 pCodeContext, out IDebugDisassemblyStream2 ppDisassemblyStream)
    {
      LoggingUtils.PrintFunction ();

      ppDisassemblyStream = null;

      return Constants.E_NOTIMPL;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetENCUpdate (out object ppUpdate)
    {
      //
      // Gets the Edit and Continue (ENC) update for this program.
      // A custom debug engine does not implement this method (it should always return E_NOTIMPL).
      //

      LoggingUtils.PrintFunction ();

      ppUpdate = null;

      return Constants.E_NOTIMPL;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetEngineInfo (out string pbstrEngine, out Guid pguidEngine)
    {
      //
      // Gets the name and identifier of the debug engine (DE) running a program.
      //

      LoggingUtils.PrintFunction ();

      pguidEngine = DebugEngineGuids.guidDebugEngineID;

      pbstrEngine = DebugEngineGuids.GetEngineNameFromId (pguidEngine);

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetMemoryBytes (out IDebugMemoryBytes2 ppMemoryBytes)
    {
      //
      // Gets the memory bytes for this program.
      //

      LoggingUtils.PrintFunction ();

      ppMemoryBytes = null;

      return Constants.S_GETMEMORYBYTES_NO_MEMORY_BYTES;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetName (out string pbstrName)
    {
      //
      // Gets the name of the program.
      //

      LoggingUtils.PrintFunction ();

      pbstrName = DebugProgram.DebugProcess.NativeProcess.Name;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetProcess (out IDebugProcess2 ppProcess)
    {
      //
      // Gets the process that this program is running in.
      //

      LoggingUtils.PrintFunction ();

      ppProcess = DebugProgram.DebugProcess;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetProgramId (out Guid pguidProgramId)
    {
      //
      // Gets a globally unique identifier for this program.
      //

      LoggingUtils.PrintFunction ();

      pguidProgramId = DebugProgram.Guid;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Step (IDebugThread2 pThread, enum_STEPKIND sk, enum_STEPUNIT Step)
    {
      //
      // Performs a step.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        JavaLangDebuggeeThread thread = pThread as JavaLangDebuggeeThread;

        uint threadId;

        LoggingUtils.RequireOk (thread.GetThreadId (out threadId));

        JdbClient.StepType stepType = (JdbClient.StepType) Step;

        switch (sk)
        {
          case enum_STEPKIND.STEP_INTO:
          {
            m_debugger.JdbClient.StepInto (threadId, stepType, false);

            break;
          }
          case enum_STEPKIND.STEP_OVER:
          {
            m_debugger.JdbClient.StepOver (threadId, stepType, false);

            break;
          }
          case enum_STEPKIND.STEP_OUT:
          {
            m_debugger.JdbClient.StepOut (threadId, stepType, false);

            break;
          }
          case enum_STEPKIND.STEP_BACKWARDS:
          {
            throw new NotImplementedException ();
          }
        }

        return Constants.S_OK;
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Terminate ()
    {
      //
      // Terminates this program.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        m_debugger.Engine.Broadcast (new JavaLangDebuggerEvent.TerminateClient (), DebugProgram, null);

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int WriteDump (enum_DUMPTYPE DUMPTYPE, string pszDumpUrl)
    {
      //
      // Writes a dump to a file.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugProgram3 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int ExecuteOnThread (IDebugThread2 pThread)
    {
      //
      // Executes the debugger program. The thread is returned to give the debugger information on which thread the user is viewing when executing the program.
      //

      LoggingUtils.PrintFunction ();

      try
      {
#if false
        uint threadId;

        CLangDebuggeeThread thread = pThread as CLangDebuggeeThread;

        LoggingUtils.RequireOk (thread.GetThreadId (out threadId));

        string command = "-thread-select " + threadId;

        MiResultRecord resultRecord = m_debugger.GdbClient.SendCommand (command);

        MiResultRecord.RequireOk (resultRecord, command);

        CurrentThreadId = threadId;
#endif

        LoggingUtils.RequireOk (Execute ());

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
