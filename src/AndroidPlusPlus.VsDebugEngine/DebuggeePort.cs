////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;
using Microsoft.VisualStudio.Debugger.Interop;
using Microsoft.VisualStudio.Shell;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices.ComTypes;
using System.Threading.Tasks;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  public class DebuggeePort : IDebugPort2, IDebugPortNotify2, IConnectionPoint, IConnectionPointContainer
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private class Enumerator : DebugEnumerator<IDebugPort2, IEnumDebugPorts2>, IEnumDebugPorts2
    {
      public Enumerator (ICollection<IDebugPort2> ports)
        : base (ports)
      {
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private readonly IDebugPortSupplier2 m_portSupplier;

    private readonly AndroidDevice m_portDevice;

    private readonly Guid m_portGuid;

    private ConcurrentDictionary<uint, DebuggeeProcess> m_portProcesses;

    private ConcurrentDictionary<int, IDebugPortEvents2> m_eventConnectionPoints;

    private int m_eventConnectionPointCookie = 1;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebuggeePort (IDebugPortSupplier2 portSupplier, AndroidDevice device)
    {
      m_portSupplier = portSupplier ?? throw new ArgumentNullException (nameof(portSupplier));

      m_portDevice = device ?? throw new ArgumentNullException (nameof(device));

      m_portGuid = Guid.NewGuid ();

      m_portProcesses = new ConcurrentDictionary<uint, DebuggeeProcess> ();

      m_eventConnectionPoints = new ConcurrentDictionary<int, IDebugPortEvents2> ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public AndroidDevice PortDevice => m_portDevice;

    public ConcurrentDictionary<uint, DebuggeeProcess> PortProcesses => m_portProcesses;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public async Task<int> RefreshProcessesAsync ()
    {
      //
      // Check which processes are currently running on the target device (port).
      //

      LoggingUtils.PrintFunction ();

      try
      {
        var currentProcesses = await AndroidAdb.ProcessesSnapshot(m_portDevice, "");

#if false
        var terminatedProcesses = m_portProcesses.Where(p => !currentProcesses.ContainsKey(p.Key));

        foreach (var deviceProcess in terminatedProcesses)
        {
          if (m_portProcesses.TryRemove(deviceProcess.Key, out DebuggeeProcess removedProcess))
          {
            Serilog.Log.Verbose($"Removed port process: {removedProcess.NativeProcess.Name} (pid: {deviceProcess.Key})");
          }
        }
#else
        Serilog.Log.Verbose($"Clearing tracked port processes.");

        m_portProcesses.Clear(); // newly spawned user applications are called "zygote" before they fork. Sadly.
#endif

        foreach (var deviceProcess in currentProcesses)
        {
          if (m_portProcesses.TryAdd(deviceProcess.Key, new DebuggeeProcess(this, deviceProcess.Value)))
          {
            Serilog.Log.Verbose($"Added port process: {deviceProcess.Value.Name} (pid: {deviceProcess.Key})");
          }
        }

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#region IDebugPort2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int EnumProcesses(out IEnumDebugProcesses2 ppEnum)
    {
      //
      // Returns a list of all the processes running on a port.
      //

      LoggingUtils.PrintFunction();

      ThreadHelper.JoinableTaskFactory.Run(async () =>
      {
        await RefreshProcessesAsync();
      });

      ppEnum = new DebuggeeProcess.Enumerator (m_portProcesses.Values.ToArray());

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetPortId (out Guid pguidPort)
    {
      //
      // Gets the port identifier.
      //

      LoggingUtils.PrintFunction ();

      pguidPort = m_portGuid;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetPortName (out string pbstrName)
    {
      //
      // Gets the port name.
      //

      LoggingUtils.PrintFunction ();

      pbstrName = m_portDevice.ID;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetPortRequest (out IDebugPortRequest2 ppRequest)
    {
      //
      // Gets the description of a port that was previously used to create the port (if available).
      //

      LoggingUtils.PrintFunction ();

      ppRequest = null;

      return Constants.E_PORT_NO_REQUEST;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetPortSupplier (out IDebugPortSupplier2 ppSupplier)
    {
      //
      // Gets the port supplier for this port.
      //

      LoggingUtils.PrintFunction ();

      ppSupplier = m_portSupplier;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetProcess (AD_PROCESS_ID ProcessId, out IDebugProcess2 ppProcess)
    {
      //
      // Gets the specified process running on a port.
      //

      LoggingUtils.PrintFunction ();

      ppProcess = null;

      try
      {
        switch (ProcessId.ProcessIdType)
        {
          case (uint)enum_AD_PROCESS_ID.AD_PROCESS_ID_SYSTEM:
          {
            if (!m_portProcesses.TryGetValue(ProcessId.dwProcessId, out DebuggeeProcess debuggeeProcess))
            {
              ThreadHelper.JoinableTaskFactory.Run(async () =>
              {
                await RefreshProcessesAsync();
              });
            }

            if (m_portProcesses.TryGetValue(ProcessId.dwProcessId, out debuggeeProcess))
            {
              ppProcess = debuggeeProcess as IDebugProcess2;
            }

            return ppProcess == null ? Constants.E_FAIL : Constants.S_OK;
          }
          default:
          {
            throw new NotImplementedException();
          }
        }
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#region IDebugPortNotify2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    [InheritGuid (typeof (IDebugProgramCreateEvent2))]
    public sealed class ProgramCreate : ImmediateDebugEvent, IDebugProgramCreateEvent2
    {
      // Immediate-mode implementation of a 'ProgramCreate' event.
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int AddProgramNode (IDebugProgramNode2 pProgramNode)
    {
      //
      // Registers a program that can be debugged with the port it is running on.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        DebuggeeProgram program = pProgramNode as DebuggeeProgram;

        LoggingUtils.RequireOk (program.GetProcess (out IDebugProcess2 process));

        foreach (IDebugPortEvents2 connectionPoint in m_eventConnectionPoints.Values)
        {
          ProgramCreate debugEvent = new ProgramCreate ();

          Guid eventGuid = ComUtils.GuidOf (debugEvent);

          int handle = connectionPoint.Event (null, this, process, program, debugEvent, ref eventGuid);

          if (handle == unchecked ((int)0x80010108)) // RPC_E_DISCONNECTED
          {
            continue; // Connection point was previously used.
          }

          LoggingUtils.RequireOk (handle);
        }

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int RemoveProgramNode(IDebugProgramNode2 pProgramNode)
    {
      //
      // Unregisters a program that can be debugged from the port it is running on.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#region IConnectionPoint Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private sealed class ConnectionEnumerator : DebugConnectionEnumerator<System.Runtime.InteropServices.ComTypes.CONNECTDATA, IEnumConnections>, IEnumConnections
    {
      public ConnectionEnumerator (ICollection<System.Runtime.InteropServices.ComTypes.CONNECTDATA> connections)
        : base (connections)
      {
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Advise (object pUnkSink, out int pdwCookie)
    {
      //
      // Establishes an advisory connection between the connection point and the caller's sink object.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        if (m_eventConnectionPoints.TryAdd (m_eventConnectionPointCookie, (IDebugPortEvents2)pUnkSink))
        {
          Serilog.Log.Information($"Added connection point with id: {m_eventConnectionPointCookie}");
        }

        pdwCookie = m_eventConnectionPointCookie++;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        pdwCookie = 0;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void EnumConnections (out IEnumConnections ppEnum)
    {
      //
      // Creates an enumerator object for iteration through the connections that exist to this connection point.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        var connections = new List<System.Runtime.InteropServices.ComTypes.CONNECTDATA> ();

        foreach (KeyValuePair <int, IDebugPortEvents2> keyPair in m_eventConnectionPoints)
        {
          connections.Add (new System.Runtime.InteropServices.ComTypes.CONNECTDATA ()
          {
            dwCookie = keyPair.Key,
            pUnk = (object) keyPair.Value
          });
        }

        ppEnum = new ConnectionEnumerator (connections);
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        ppEnum = null;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void GetConnectionInterface (out Guid pIID)
    {
      //
      // Returns the IID of the outgoing interface managed by this connection point.
      //

      LoggingUtils.PrintFunction ();

      pIID = ComUtils.GuidOf (typeof (IDebugPortEvents2));
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void GetConnectionPointContainer (out IConnectionPointContainer ppCPC)
    {
      //
      // Retrieves the IConnectionPointContainer interface pointer to the connectable object that conceptually owns this connection point.
      //

      LoggingUtils.PrintFunction ();

      ppCPC = this;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Unadvise (int dwCookie)
    {
      //
      // Terminates an advisory connection previously established through the System.Runtime.InteropServices.ComTypes.IConnectionPoint.Advise(System.Object,System.Int32@) method.
      //

      LoggingUtils.PrintFunction ();

      if (m_eventConnectionPoints.TryRemove(dwCookie, out IDebugPortEvents2 connectionPoint))
      {
        Serilog.Log.Information($"Removed connection point with id: {dwCookie}");
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#region IConnectionPointContainer Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private sealed class ConnectionPointEnumerator : DebugConnectionEnumerator<IConnectionPoint, IEnumConnectionPoints>, IEnumConnectionPoints
    {
      public ConnectionPointEnumerator (ICollection<IConnectionPoint> points)
        : base (points)
      {
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void EnumConnectionPoints (out IEnumConnectionPoints ppEnum)
    {
      //
      // Creates an enumerator of all the connection points supported in the connectable object, one connection point per IID.
      //

      LoggingUtils.PrintFunction();

      ppEnum = new ConnectionPointEnumerator(new IConnectionPoint[] { this });
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void FindConnectionPoint (ref Guid riid, out IConnectionPoint ppCP)
    {
      //
      // Asks the connectible object if it has a connection point for a particular IID,
      // and if so, returns the IConnectionPoint interface pointer to that connection point.
      //

      LoggingUtils.PrintFunction();

      GetConnectionInterface (out Guid connectionPort);

      ppCP = riid.Equals(connectionPort) ? this : null;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

}
