////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;
using System;
using System.Collections.Generic;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public class DebugEnumerator<T, I> where I: class
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private readonly ICollection<T> m_data;

    private uint m_position;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebugEnumerator (ICollection<T> data)
    {
      if (data == null)
      {
        throw new ArgumentNullException(nameof(data));
      }

      m_data = data;

      m_position = 0;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Clone (out I ppEnum)
    {
      // 
      // Creates an enumerator that contains the same enumeration state as the current enumerator.
      // 

      ppEnum = new DebugConnectionEnumerator<T, I> (m_data, m_position) as I;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetCount (out uint pcelt)
    {
      // 
      // Gets the number of ports in an enumerator.
      // 

      pcelt = (uint)m_data.Count;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Next (uint celt, T [] rgelt, IntPtr celtFetched)
    {
      // 
      // Retrieves a specified number of ports in an enumeration sequence.
      // 

      return Next (celt, rgelt, celtFetched);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Next (uint celt, T [] rgelt, ref uint celtFetched)
    {
      // 
      // Retrieves a specified number of ports in an enumeration sequence.
      // 

      return Move (celt, rgelt, out celtFetched);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Reset ()
    {
      // 
      // Resets an enumeration sequence to the beginning.
      // 

      m_position = 0;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int Skip (uint celt)
    {
      // 
      // Skips a specified number of ports in an enumeration sequence.
      // 

      LoggingUtils.PrintFunction ();

      return Move (celt, null, out uint celtFetched);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private int Move (uint celt, T[] rgelt, out uint celtFetched)
    {
      LoggingUtils.PrintFunction ();

      int hr = Constants.S_OK;

      celtFetched = (uint)m_data.Count - m_position;

      if (celt > celtFetched)
      {
        hr = Constants.S_FALSE;
      }
      else if (celt < celtFetched)
      {
        celtFetched = celt;
      }

      if (rgelt != null)
      {
        var duplicate = new T[m_data.Count];

        m_data.CopyTo(duplicate, 0);

        Array.Copy(duplicate, rgelt, celtFetched);
      }

      m_position += celtFetched;

      return hr;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
