////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Diagnostics;
using Microsoft.VisualStudio.Debugger.Interop;
using AndroidPlusPlus.Common;
using AndroidPlusPlus.VsDebugCommon;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.VsDebugEngine
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public class DebuggeeStackFrame : IDebugStackFrame3, IDebugExpressionContext2
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public class Enumerator : DebugEnumerator<FRAMEINFO, IEnumDebugFrameInfo2>, IEnumDebugFrameInfo2
    {
      public Enumerator (ICollection<FRAMEINFO> frames)
        : base (frames)
      {
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected readonly DebugEngine m_debugEngine;

    protected readonly DebuggeeThread m_thread;

    protected DebuggeeCodeContext m_codeContext;

    protected DebuggeeDocumentContext m_documentContext;

    protected DebuggeeProperty m_property;

    protected ConcurrentDictionary<string, DebuggeeProperty> m_stackRegisters;

    protected ConcurrentDictionary<string, DebuggeeProperty> m_stackArguments;

    protected ConcurrentDictionary<string, DebuggeeProperty> m_stackLocals;

    protected ConcurrentDictionary<string, DebuggeeProperty> m_customExpressions;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public DebuggeeStackFrame (DebugEngine engine, DebuggeeThread thread, string frameName)
    {
      m_debugEngine = engine;

      m_thread = thread;

      m_codeContext = null;

      m_documentContext = null;

      m_property = new DebuggeeProperty (engine, this, frameName, string.Empty);

      m_stackRegisters = new ConcurrentDictionary<string, DebuggeeProperty> ();

      m_stackArguments = new ConcurrentDictionary<string, DebuggeeProperty> ();

      m_stackLocals = new ConcurrentDictionary<string, DebuggeeProperty> ();

      m_customExpressions = new ConcurrentDictionary<string, DebuggeeProperty> ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public virtual void Delete ()
    {
      m_stackRegisters.Clear ();

      m_stackArguments.Clear ();

      m_stackLocals.Clear ();

      m_customExpressions.Clear ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public virtual int SetFrameInfo (enum_FRAMEINFO_FLAGS requestedFlags, uint radix, ref FRAMEINFO frameInfo)
    {
      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected virtual int QueryArgumentsAndLocals ()
    {
      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected virtual int QueryRegisters ()
    {
      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugStackFrame2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public virtual int EnumProperties (enum_DEBUGPROP_INFO_FLAGS requestedFields, uint radix, ref Guid guidFilter, uint timeout, out uint elementsReturned, out IEnumDebugPropertyInfo2 enumDebugProperty)
    {
      //
      // Creates an enumerator for properties associated with the stack frame, such as local variables.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        uint numEnumeratedProperties;

        IEnumDebugPropertyInfo2 enumeratedProperties;

        LoggingUtils.RequireOk (m_property.EnumChildren (requestedFields, radix, ref guidFilter, enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_ALL, string.Empty, timeout, out enumeratedProperties));

        LoggingUtils.RequireOk (enumeratedProperties.GetCount (out numEnumeratedProperties));

        elementsReturned = numEnumeratedProperties;

        enumDebugProperty = enumeratedProperties;

#if false
        //List<DEBUG_PROPERTY_INFO> filteredProperties;

        if ((guidFilter == DebuggeeProperty.Filters.guidFilterRegisters)
          || (guidFilter == DebuggeeProperty.Filters.guidFilterAutoRegisters))
        {
          //
          // Registers must be specified in a collection/list as children of a 'CPU' property.
          //

          DEBUG_PROPERTY_INFO [] debugProperties = new DEBUG_PROPERTY_INFO [numEnumeratedProperties];

          LoggingUtils.RequireOk (enumeratedProperties.Next (numEnumeratedProperties, debugProperties, out numEnumeratedProperties));

          DebuggeeProperty registersProperty = new DebuggeeProperty (m_debugEngine, this, "CPU", string.Empty);

          for (uint i = 0; i < numEnumeratedProperties; ++i)
          {
            DebuggeeProperty register;

            if (m_stackRegisters.TryGetValue (debugProperties [i].bstrName, out register))
            {
              registersProperty.AddChildren (new DebuggeeProperty [] { register });
            }
          }

          DEBUG_PROPERTY_INFO [] infoArray = new DEBUG_PROPERTY_INFO [1];

          LoggingUtils.RequireOk (registersProperty.GetPropertyInfo (requestedFields, radix, timeout, null, 0, infoArray));

          elementsReturned = (uint) infoArray.Length;

          enumDebugProperty = new DebuggeeProperty.Enumerator (infoArray);
        }

        /*DEBUG_PROPERTY_INFO [] debugProperties = new DEBUG_PROPERTY_INFO [numProperties];

        LoggingUtils.RequireOk (enumeratedProperties.Next (numProperties, debugProperties, out numProperties));

        if ((guidFilter == DebuggeeProperty.Filters.guidFilterRegisters) || (guidFilter == DebuggeeProperty.Filters.guidFilterAutoRegisters))
        {
          //
          // Registers must be specified in a collection/list as children of a 'CPU' property.
          //

          DebuggeeProperty registersProperty = new DebuggeeProperty (m_debugEngine, this, "CPU", string.Empty);

          for (uint i = 0; i < numProperties; ++i)
          {
            DebuggeeProperty register;

            if (m_stackRegisters.TryGetValue (debugProperties [i].bstrName, out register))
            {
              registersProperty.AddChildren (new DebuggeeProperty [] { register });
            }
          }

          DEBUG_PROPERTY_INFO [] infoArray = new DEBUG_PROPERTY_INFO [1];

          LoggingUtils.RequireOk (registersProperty.GetPropertyInfo (requestedFields, radix, timeout, null, 0, infoArray));

          filteredProperties = new List<DEBUG_PROPERTY_INFO> (1);

          filteredProperties.Add (infoArray [0]);
        }
        else
        {
          filteredProperties = new List<DEBUG_PROPERTY_INFO> ((int)numProperties);

          for (uint i = 0; i < numProperties; ++i)
          {
            //
            // Determine whether this property should be filtered in/out.
            //

            bool displayProperty = false;

            DEBUG_PROPERTY_INFO prop = debugProperties [i];

            if ((guidFilter == DebuggeeProperty.Filters.guidFilterAllLocals)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterAllLocalsPlusArgs))
            {
              displayProperty |= true;
            }

            if ((guidFilter == DebuggeeProperty.Filters.guidFilterArgs)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterAllLocalsPlusArgs)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterLocalsPlusArgs))
            {
              displayProperty |= m_stackArguments.ContainsKey (prop.bstrName);
            }

            if ((guidFilter == DebuggeeProperty.Filters.guidFilterAllLocals)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterAllLocalsPlusArgs)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterLocals)
              || (guidFilter == DebuggeeProperty.Filters.guidFilterLocalsPlusArgs))
            {
              displayProperty |= m_stackLocals.ContainsKey (prop.bstrName);
            }

            if (displayProperty)
            {
              filteredProperties.Add (prop);
            }
          }
        }*/
#endif

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        elementsReturned = 0;

        enumDebugProperty = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetCodeContext (out IDebugCodeContext2 codeContext)
    {
      //
      // Gets the code context for this stack frame.
      // The code context represents the current instruction pointer in this stack frame.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        codeContext = m_codeContext;

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        codeContext = null;

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetDebugProperty (out IDebugProperty2 property)
    {
      //
      // Gets a description of the properties of a stack frame.
      // Calling the IDebugProperty2::EnumChildren method with appropriate filters can retrieve the local variables, method parameters, registers,
      // and "this" pointer associated with the stack frame. The debugger calls EnumProperties to obtain these values in the sample.
      //

      LoggingUtils.PrintFunction ();

      property = m_property;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetDocumentContext (out IDebugDocumentContext2 documentContext)
    {
      //
      // Gets the document context for this stack frame.
      // The debugger will call this when the current stack frame is changed
      // and will use it to open the correct source document for this stack frame.
      //

      LoggingUtils.PrintFunction ();

      documentContext = m_documentContext;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetExpressionContext (out IDebugExpressionContext2 expressionContext)
    {
      //
      // Gets an evaluation context for expression evaluation within the current context of a stack frame and thread.
      //

      LoggingUtils.PrintFunction ();

      expressionContext = this;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetInfo (enum_FRAMEINFO_FLAGS requestedFields, uint radix, FRAMEINFO [] frameInfoArray)
    {
      //
      // Gets a description of the stack frame.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        LoggingUtils.RequireOk (SetFrameInfo (requestedFields, radix, ref frameInfoArray [0]));

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public virtual int GetLanguageInfo (ref string languageName, ref Guid languageGuid)
    {
      //
      // Gets the language associated with this stack frame.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        IDebugDocumentContext2 documentContext;

        languageGuid = DebugEngineGuids.guidLanguageUnknown;

        languageName = DebugEngineGuids.GetLanguageName (languageGuid);

        LoggingUtils.RequireOk (GetDocumentContext (out documentContext));

        if (documentContext != null)
        {
          LoggingUtils.RequireOk (documentContext.GetLanguageInfo (ref languageName, ref languageGuid));
        }

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetName (out string name)
    {
      //
      // Gets the name of the stack frame.
      // The name of a stack frame is typically the name of the method being executed.
      //

      LoggingUtils.PrintFunction ();

      name = string.Empty;

      try
      {
        uint radix = 10;

        FRAMEINFO frameInfo = new FRAMEINFO ();

        LoggingUtils.RequireOk (SetFrameInfo (enum_FRAMEINFO_FLAGS.FIF_FUNCNAME, radix, ref frameInfo));

        name = frameInfo.m_bstrFuncName;

        if (string.IsNullOrEmpty (name))
        {
          throw new InvalidOperationException ();
        }

        return Constants.S_OK;
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        return Constants.E_FAIL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetPhysicalStackRange (out ulong addrMin, out ulong addrMax)
    {
      //
      // Gets a machine-dependent representation of the range of physical addresses associated with a stack frame.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        addrMin = 0;

        addrMax = 0;

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetThread (out IDebugThread2 thread)
    {
      //
      // Gets the thread associated with a stack frame.
      //

      LoggingUtils.PrintFunction ();

      thread = m_thread;

      if (thread == null)
      {
        return Constants.S_FALSE;
      }

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugStackFrame3 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int GetUnwindCodeContext (out IDebugCodeContext2 ppCodeContext)
    {
      //
      // Returns the code context representing a location if a stack unwind operation occurred.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        ppCodeContext = null;

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int InterceptCurrentException (enum_INTERCEPT_EXCEPTION_ACTION dwFlags, out ulong pqwCookie)
    {
      //
      // Called by the debugger on the current stack frame when it wants to intercept the current exception.
      //

      LoggingUtils.PrintFunction ();

      try
      {
        throw new NotImplementedException ();
      }
      catch (NotImplementedException e)
      {
        LoggingUtils.HandleException (e);

        pqwCookie = 0;

        return Constants.E_NOTIMPL;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #region IDebugExpressionContext2 Members

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int IDebugExpressionContext2.GetName (out string name)
    {
      //
      // Retrieves the name of the evaluation context.
      // The name is the description of this evaluation context. It is typically something that can be parsed by an expression evaluator
      // that refers to this exact evaluation context. For example, in C++ the name is as follows:
      // "{ function-name, source-file-name, module-file-name }"
      //

      LoggingUtils.PrintFunction ();

      try
      {
        LoggingUtils.RequireOk (GetName (out name));
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);

        name = string.Empty;

        return Constants.E_FAIL;
      }

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public int ParseText (string pszCode, enum_PARSEFLAGS dwFlags, uint nRadix, out IDebugExpression2 ppExpr, out string pbstrError, out uint pichError)
    {
      //
      // Parses an expression in text form for later evaluation.
      //

      LoggingUtils.PrintFunction ();

      ppExpr = new DebuggeeExpression (m_debugEngine, this, pszCode, nRadix);

      pbstrError = string.Empty;

      pichError = (uint)pbstrError.Length;

      return Constants.S_OK;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    #endregion

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
