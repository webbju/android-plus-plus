using AndroidPlusPlus.MsBuild.Common;
using Microsoft.Build.Framework;
using Microsoft.Build.Framework.XamlTypes;
using Microsoft.Build.Tasks.Xaml;
using Microsoft.Build.Utilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AndroidPlusPlus.MsBuild.Tests
{
  [TestClass]
  public class XamlParserTests
  {
    private const string testXamlFile = @"<?xml version='1.0' encoding='utf-8'?>
<Rule Name='mem' ToolName='mem.exe' PageTemplate='tool' SwitchPrefix='/' Order='10' xmlns='clr-namespace:Microsoft.Build.Framework.XamlTypes;assembly=Microsoft.Build.Framework' xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml' xmlns:sys='clr-namespace:System;assembly=mscorlib'>
  <Rule.DisplayName>
    <sys:String>Memory Reporting Tool</sys:String>
  </Rule.DisplayName>
  <Rule.Categories>
    <Category Name='General'>
      <Category.DisplayName>
        <sys:String>General</sys:String>
      </Category.DisplayName>
    </Category>
  </Rule.Categories>
  <Rule.DataSource>
    <DataSource Persistence='ProjectFile' ItemType='ClCompile' Label='' HasConfigurationCondition='true' />
  </Rule.DataSource>
  <BoolProperty Name='Program' Category='General' Switch='P'/>
  <BoolProperty Name='Debug' Category='General' Switch='D'/>
  <BoolProperty Name='Classify' Category='General' Switch='C'/>
  <StringProperty Name='Subst' Category='Command Line' Switch='S[value]_postfix' />
  <StringProperty Name='Subst2' Category='Command Line' />
  <StringProperty Name='Subst3' Category='Command Line' Switch='AtEnd[value]' />
  <StringProperty Name='Subst4' Category='Command Line' Switch='X' Separator='=' />
  <IntProperty Name='SubstInt' Category='Command Line' Switch='I[value]_postfix' />
  <StringListProperty Name='Strings' Switch='X' />
  <StringProperty Name='Sources' Category='Command Line' IsRequired='true'>
    <StringProperty.DataSource>
      <DataSource Persistence='ProjectFile' ItemType='ClCompile' SourceType='Item' Label='' HasConfigurationCondition='true' />
    </StringProperty.DataSource>
  </StringProperty>
  <EnumProperty Name='DebugInformationFormat' Category='General'>
    <EnumProperty.DisplayName>
      <sys:String>Debug Information Format</sys:String>
    </EnumProperty.DisplayName>
    <EnumProperty.Description>
      <sys:String>Specifies the type of debugging information generated by the compiler.  You must also change linker settings appropriately to match.    (/Z7, Zd, /Zi, /ZI)</sys:String>
    </EnumProperty.Description>
    <EnumValue Name='OldStyle' Switch='Z7'>
      <EnumValue.DisplayName>
        <sys:String>C7 compatible</sys:String>
      </EnumValue.DisplayName>
      <EnumValue.Description>
        <sys:String>Select the type of debugging information created for your program and whether this information is kept in object (.obj) files or in a program database (PDB).</sys:String>
      </EnumValue.Description>
    </EnumValue>
    <EnumValue Name='ProgramDatabase' Switch='Zi'>
      <EnumValue.DisplayName>
        <sys:String>Program Database</sys:String>
      </EnumValue.DisplayName>
      <EnumValue.Description>
        <sys:String>Produces a program database (PDB) that contains type information and symbolic debugging information for use with the debugger. The symbolic debugging information includes the names and types of variables, as well as functions and line numbers. </sys:String>
      </EnumValue.Description>
    </EnumValue>
    <EnumValue Name='EditAndContinue' Switch='ZI'>
      <EnumValue.DisplayName>
        <sys:String>Program Database for Edit And Continue</sys:String>
      </EnumValue.DisplayName>
      <EnumValue.Description>
        <sys:String>Produces a program database, as described above, in a format that supports the Edit and Continue feature.</sys:String>
      </EnumValue.Description>
    </EnumValue>
  </EnumProperty>
  <EnumProperty Name='EmptyTest' Category='General'>
    <EnumProperty.DisplayName>
      <sys:String>Empty Enum</sys:String>
    </EnumProperty.DisplayName>
    <EnumProperty.Description>
      <sys:String>Specifies the type of debugging information generated by the compiler.  You must also change linker settings appropriately to match.    (/Z7, Zd, /Zi, /ZI)</sys:String>
    </EnumProperty.Description>
    <EnumValue Name='Empty' >
      <EnumValue.DisplayName>
        <sys:String>Empty</sys:String>
      </EnumValue.DisplayName>
      <EnumValue.Description>
        <sys:String>An empty enum switch</sys:String>
      </EnumValue.Description>
    </EnumValue>
  </EnumProperty>
</Rule>
        ";

    [TestMethod]
    public void ParseTextBufferRule()
    {
      var parser = new Common.CommandLineGenerator();

      var xamlResult = Common.CommandLineGenerator.ParseXamlRule(testXamlFile);

      Assert.IsNotNull(xamlResult);

      Assert.IsInstanceOfType(xamlResult, typeof(Rule));

      var propertyValues = new Dictionary<string, object>();

      propertyValues["Program"] = true;

      propertyValues["Debug"] = null;

      propertyValues["Subst"] = "SubstituteThis!";

      propertyValues["Subst2"] = "SubstituteThis!AsWell";

      propertyValues["Subst3"] = "Substitute\\";

      propertyValues["Subst4"] = "Separator";

      propertyValues["SubstInt"] = (int)42;

      propertyValues["Strings"] = new string[] { "one", "two", "three" };

      propertyValues["Sources"] = new ITaskItem[] { new TaskItem("a.cs"), new TaskItem("b.cs") };

      propertyValues["DebugInformationFormat"] = "OldStyle";

      propertyValues["EmptyTest"] = "Empty";

      var builder = parser.GenerateCommandLine(xamlResult, propertyValues);

      var commandLine = builder.ToString();

      Trace.WriteLine(commandLine);

      //Assert.AreEqual("/P /SSubstituteThis!_postfix SubstituteThis!AsWell /AtEndSubstitute\\ /X=Separator /I42_postfix /Xone /Xtwo /Xthree a.cs b.cs /Z7", commandLine);
    }
  }
}
