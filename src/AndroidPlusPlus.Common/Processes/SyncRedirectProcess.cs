////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.Common
{

  public partial class SyncRedirectProcess : IDisposable
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected int m_startTimestamp = 0;

    protected int m_lastOutputTimestamp = 0;

    protected int m_exitCode = -1;

    protected RedirectEventListener m_listener;

    protected StringBuilder m_standardOutput = new StringBuilder();

    protected StringBuilder m_standardError = new StringBuilder();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public SyncRedirectProcess (string filename, string arguments, string workingDirectory = null)
    {
      if (string.IsNullOrEmpty (filename))
      {
        throw new ArgumentNullException (nameof(filename));
      }

      if (!File.Exists (filename))
      {
        throw new FileNotFoundException ("Could not find target executable.", filename);
      }

      StartInfo = CreateDefaultStartInfo (filename, arguments, workingDirectory);

      StartInfo.FileName = filename;

      StartInfo.Arguments = arguments;

      StartInfo.WorkingDirectory = workingDirectory ?? Path.GetDirectoryName (filename);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public Process Process { get; protected set; }

    public ProcessStartInfo StartInfo { get; protected set; }

    public string StandardOutput => m_standardOutput.ToString();

    public string StandardError => m_standardError.ToString();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Dispose ()
    {
      Dispose (true);

      GC.SuppressFinalize (this);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected virtual void Dispose (bool disposing)
    {
      if (disposing)
      {
        if (Process != null)
        {
          Process.Dispose ();

          Process = null;
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected static ProcessStartInfo CreateDefaultStartInfo (string filename, string arguments, string workingDirectory = null)
    {
      var startInfo = new ProcessStartInfo
      {
        FileName = filename ?? throw new ArgumentNullException(nameof(filename)),

        Arguments = arguments,

        WorkingDirectory = workingDirectory ?? Path.GetDirectoryName(filename),

        CreateNoWindow = true,

        UseShellExecute = false,

        LoadUserProfile = false,

        ErrorDialog = false,

        RedirectStandardOutput = true,

        RedirectStandardError = true,

        RedirectStandardInput = true
      };

      return startInfo;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Start (RedirectEventListener listener)
    {
      m_listener = listener;

      Process = new Process
      {
        StartInfo = StartInfo,

        EnableRaisingEvents = true,
    };

      Process.OutputDataReceived += new DataReceivedEventHandler(ProcessStdout);

      Process.ErrorDataReceived += new DataReceivedEventHandler(ProcessStderr);

      Process.Exited += new EventHandler(ProcessExited);

      LoggingUtils.Print (string.Format ("[SyncRedirectProcess] Start: {0} (Args=\"{1}\" Pwd=\"{2}\")", Process.StartInfo.FileName, Process.StartInfo.Arguments, Process.StartInfo.WorkingDirectory));

      m_startTimestamp = Environment.TickCount;

      m_lastOutputTimestamp = m_startTimestamp;

      Process.Start ();

      Process.BeginOutputReadLine();

      Process.BeginErrorReadLine();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public void Kill ()
    {
      LoggingUtils.PrintFunction ();

      try
      {
        if (!Process?.HasExited ?? false)
        {
          Process.Kill ();
        }
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException (e);
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public (int exitCode, string standardOutput, string standardError) StartAndWaitForExit (int idleTimeoutMs = 5000, RedirectEventListener listener = null)
    {
      try
      {
        Start(listener);

        int timeoutFromCurrentTick = (idleTimeoutMs + m_lastOutputTimestamp) - Environment.TickCount;

        bool responseSignaled = false;

        while (!responseSignaled && timeoutFromCurrentTick > 0)
        {
          if (Process.WaitForExit(0))
          {
            responseSignaled = true;

            break;
          }

          timeoutFromCurrentTick = (idleTimeoutMs + m_lastOutputTimestamp) - Environment.TickCount;

          Thread.Sleep(100);
        }

        if (!responseSignaled)
        {
          throw new TimeoutException($"Process was idle for over threshold ({idleTimeoutMs} ms).");
        }

        LoggingUtils.Print($"[SyncRedirectProcess] {StartInfo.FileName} exited with code {m_exitCode} in {(Environment.TickCount - m_startTimestamp)} ms");
      }
      catch (Exception e)
      {
        LoggingUtils.HandleException(e);
      }

      return (m_exitCode, m_standardOutput.ToString(), m_standardError.ToString());
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected void ProcessStdout(object sendingProcess, DataReceivedEventArgs args)
    {
      if (string.IsNullOrEmpty(args.Data))
      {
        return;
      }

      m_lastOutputTimestamp = Environment.TickCount;

      m_standardOutput.AppendLine(args.Data);

      m_listener?.ProcessStdout(sendingProcess, args);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected void ProcessStderr(object sendingProcess, DataReceivedEventArgs args)
    {
      if (string.IsNullOrEmpty(args.Data))
      {
        return;
      }

      m_lastOutputTimestamp = Environment.TickCount;

      m_standardError.AppendLine(args.Data);

      m_listener?.ProcessStderr(sendingProcess, args);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    protected void ProcessExited(object sendingProcess, EventArgs args)
    {
      m_exitCode = Process.ExitCode;

      m_listener?.ProcessExited(sendingProcess, args);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

}
