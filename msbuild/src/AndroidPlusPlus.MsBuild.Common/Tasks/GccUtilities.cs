////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

using Microsoft.Build.Framework;
using Microsoft.Win32;
using Microsoft.Build.Utilities;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace AndroidPlusPlus.MsBuild.Common
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public static class GccUtilities
  {

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public static string ConvertGccOutputToVS (string line)
    {
      // 
      // Parse and reformat GCC error and warning output into a Visual Studio 'jump to line' style.
      // 

      StringBuilder vsOutputBuilder = new StringBuilder (line);

      string [] patterns = new string []
      {
        // "src/foo.c:25: error: new.h: No such file or directory"
        // "src/foo.c:13:15: error: undefined reference to 'native_library_a_dummy()'"
        "^(?<sourcefile>.?.?[^:]*.*?):(?<row>[0-9]*):?(?<column>[0-9]*)?: (?<message>.*$)",

        // "debug/foo.obj:src/foo.c:38: first defined here"
        "^(?<objectfile>.?.?[^:]*.*?):(?<sourcefile>.?.?[^:]*.*?):?(?<row>[0-9]*)?: (?<message>.*$)",

        // debug/libFoobar.a(foo.obj):src/foo.c:function AnExampleFunction::nativeMethodDefs: error: undefined reference to 'nativeCallback(_JNIEnv*, _jobject*, _jstring*)'
        "^(?<objectfile>.?.?[^:]*.*?):(?<sourcefile>.?.?[^:]*.*?):function (?<function>[^ ]*)(?<message>.*$)",
      };

      foreach (string pattern in patterns)
      {
        Regex regExMatcher = new Regex (pattern, RegexOptions.Compiled);

        Match regExMatch = regExMatcher.Match (line);

        if (regExMatch.Success)
        {
          string sourcefile = regExMatch.Result ("${sourcefile}");

          string objectfile = regExMatch.Result ("${objectfile}");

          string row = regExMatch.Result ("${row}");

          string column = regExMatch.Result ("${column}");

          string function = regExMatch.Result ("${function}");

          string message = regExMatch.Result ("${message}");

          vsOutputBuilder.Clear ();

          if (!string.IsNullOrWhiteSpace (sourcefile) && !sourcefile.Equals ("${sourcefile}"))
          {
            vsOutputBuilder.Append (PathUtils.ConvertPathCygwinToWindows (sourcefile));
          }

          if (!string.IsNullOrWhiteSpace (row) && !row.Equals ("${row}"))
          {
            if (string.IsNullOrWhiteSpace (column) && !column.Equals ("${column}"))
            {
              vsOutputBuilder.AppendFormat ("({0},{1})", row, column);
            }
            else
            {
              vsOutputBuilder.AppendFormat ("({0})", row);
            }
          }

          vsOutputBuilder.Append (": ");

          if (!string.IsNullOrWhiteSpace (message))
          {
            vsOutputBuilder.Append (message);
          }

#if false
          if (!string.IsNullOrWhiteSpace (function))
          {
            vsOutputBuilder.AppendFormat (" ({0})", function.Trim (new char [] { ':' }));
          }
#endif

          break;
        }
      }

      vsOutputBuilder.Replace ("error: ", "error : ");

      vsOutputBuilder.Replace ("warning: ", "warning : ");

      return vsOutputBuilder.ToString ();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    public class DependencyParser
    {

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      private ITaskItem m_outputFile;

      private Dictionary<string, ITaskItem> m_dependencies;

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public DependencyParser ()
      {
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public ITaskItem OutputFile
      {
        get
        {
          return m_outputFile;
        }
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public Dictionary<string, ITaskItem>.ValueCollection Dependencies
      {
        get
        {
          return m_dependencies.Values;
        }
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public void Parse (string dependencyFile)
      {
        // 
        // Parse GCC and Java-style dependency files.
        // 
        // GCC:
        //  AndroidMT/Debug/native-media-jni.obj: \
        //   C:/Users/Justin/documents/visual\ studio\ 2010/Projects/native-media/native-media/jni/native-media-jni.c \
        // 
        // JAVA:
        //  AndroidMT/Debug/native-media-jni.class \
        //   : C:/Users/Justin/documents/visual\ studio\ 2010/Projects/native-media/native-media/jni/native-media-jni.java \
        // 

        // 
        // To reading variable ':' placement headers easier, we read the entire file and reconstitute it around ': ' and ' \'.
        // 

        string fileContents = File.ReadAllText (dependencyFile);

        fileContents = fileContents.Replace (System.Environment.NewLine, "");

        string [] dependencyEntries = fileContents.Split (new string [] { ": \\", " \\", ": " }, StringSplitOptions.RemoveEmptyEntries);

        for (int i = 0; i < dependencyEntries.Length; ++i)
        {
          string line = dependencyEntries [i].Replace (": ", "").Replace (" \\", "").Trim ();

          if (!string.IsNullOrWhiteSpace (line))
          {
            if (i == 0)
            {
              string outputFilePath = PathUtils.UnescapePath (line);

              m_outputFile = new TaskItem (outputFilePath);

              m_dependencies = new Dictionary<string, ITaskItem> (dependencyEntries.Length);
            }
            else
            {
              ParseDependencyLine (line);
            }
          }
        }
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      private void ParseDependencyLine (string line)
      {
        if (string.IsNullOrWhiteSpace (line))
        {
          return;
        }

        // 
        // Remove a trailing '\' character used to signify the list continues on the next line.
        // 

        if (line.EndsWith (@"\"))
        {
          line = line.Substring (0, line.Length - 1);
        }

        line.Trim ();

        // 
        // Now iterate through the line which can contain zero or more dependencies.
        // Although they are seperated by spaces we can't use Split() here since filenames
        // can also contain spaces that are escaped using backslash.  For some reason only
        // spaces are escaped.  Even literal backslash chars don't need escaping.
        // 

        while ((line.Length > 0) && (!string.IsNullOrWhiteSpace (line)))
        {
          int end = FindEndOfFilename (line);

          string filename = line.Substring (0, end);

          if (!string.IsNullOrWhiteSpace (filename))
          {
            // 
            // Files with spaces in look like this:
            //  C:\Program\ Files\ (x86)\ARM\Mali\ Developer\ Tools\OpenGL\ ES\ 1.1\ Emulator\ v1.0\include/GLES2/gl2ext.h \
            // 

            filename = PathUtils.UnescapePath (filename);

            filename = PathUtils.ConvertPathCygwinToWindows (filename);

            if (!m_dependencies.ContainsKey (filename))
            {
              m_dependencies.Add (filename, new TaskItem (filename));
            }
          }

          if (end == line.Length)
          {
            break;
          }

          line = line.Substring (end + 1).Trim ();
        }
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      private static int FindEndOfFilename (string line)
      {
        // 
        // Search line for an unescaped space character (which represents the end of file), or EOF.
        // 

        int i;

        bool escapedSequence = false;

        for (i = 0; i < line.Length; ++i)
        {
          if (line [i] == '\\')
          {
            escapedSequence = true;
          }
          else if ((line [i] == ' ') && !escapedSequence)
          {
            break;
          }
          else if (escapedSequence)
          {
            escapedSequence = false;
          }
        }

        return i;
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public static void ConvertJavaDependencyFileToGcc (string dependencyFile)
      {
        // 
        // Load a specified dependency file and convert any invalid (windows) paths, to escaped-posix.
        // 

        if (string.IsNullOrWhiteSpace (dependencyFile))
        {
          throw new ArgumentNullException ("dependencyFile");
        }

        if (!File.Exists (dependencyFile))
        {
          throw new FileNotFoundException ("Could not find dependency file: " + dependencyFile);
        }

        string dependencyFileTemp = dependencyFile + ".tmp";

        using (StreamReader reader = new StreamReader (dependencyFile))
        {
          using (StreamWriter writer = new StreamWriter (dependencyFileTemp, false, Encoding.Unicode))
          {
            StringBuilder builder = new StringBuilder (2048);

            string line = reader.ReadLine ();

            while (!string.IsNullOrWhiteSpace (line))
            {
              builder.Length = 0;

              builder.Append (line);

              // 
              // Remove a trailing '\' character used to signify the list continues on the next line.
              // 

              if (line.EndsWith (@"\"))
              {
                line = line.Substring (0, line.Length - 1);
              }

              line.Trim ();

              builder.Replace (line, ConvertPathWindowsToDependencyFormat (line));

              builder.Replace (@"\ \", @" \"); // patch line endings

              builder.Replace (@"\ :\ ", @" : "); // patch output directive

              writer.WriteLine (builder.ToString ());

              line = reader.ReadLine ();
            }

            writer.Close ();
          }

          reader.Close ();
        }

        File.Copy (dependencyFileTemp, dependencyFile, true);

        File.Delete (dependencyFileTemp);
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      public static string ConvertPathWindowsToDependencyFormat (string path)
      {
        string rtn = path.Replace ('\\', '/');

        return PathUtils.EscapePath (rtn);
      }

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
